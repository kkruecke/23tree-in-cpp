<h1>TODO</h1>

<p>Implement emplace after understanding the Qs below</p>

<pre><code>template&lt;class Key, class Value&gt; class tree23 {

   //...
   public:
   //...
    template &lt;class... Args&gt; void emplace (Args&amp;&amp;... args);
};

template&lt;class Key, class Value&gt;  template&lt;class Args&gt;
void tree23&lt;Key, Value&gt;::emplace(Args&amp;&amp;... args)
{
 /* 
   Q1:  How do you get the key, which is the first argument, so you can set the value of pair::first?
   Q2:  How do you get the remaining arguments, minus the first argument, so you can std::forward() them to pair::second?
  */
}
</code></pre>

<p>Answer: Note this clue from http://en.cppreference.com/w/cpp/container/map/emplace, which mentions that pair's template constructor is used for
`tempate<class Args...> iterator map<key, value>::emplace(Args&amp;&amp;...args);</p>

<pre><code>std::map&lt;std::string, std::string&gt; m;

// uses pair's template constructor
m.emplace("d", "ddd"); //&lt;-- The key is "d", the
</code></pre>

<p>So <code>template&lt; class U1, class U2 &gt; constexpr pair( U1&amp;&amp; x, U2&amp;&amp; y );</code> is used. So if I don't use pair, then maybe this will work:</p>

<pre><code>template&lt;class Key, class Value&gt; void emplace(Key&amp;&amp; key, Value&amp;&amp; v);
</code></pre>

<p>For Help See These Links</p>

<ol>
<li>[vt] - Variadic Templates C++11 </li>
<li>[cpp] - std::map emplace()</li>
</ol>

<h2>Overview</h2>

<h3>Implementation Links and Discusssion</h3>

<ol>
<li>[odu] - Traversing Trees with Iterator, an STL-compatible iterator Q&amp;A teaching discussion</li>
<li>[geeksforgeeks] - Conceptual Discussion with C code implementation using a stack.</li>
<li>[stackoverflow] - Stackoverflow Discussion with a link to SGI STL implmentation </li>
<li>[FSU] - FSU lecture that discusses external bidirectional tree iterator in C++</li>
<li>[cmu] - See Non-Recursive Traversals section that discuss forward iteration in Java using a stack</li>
<li>[csohio] - Discusses trees and has an implementation in Java</li>
</ol>

<h3>Top level pseudo code.</h3>

<p><code>begin()</code> calls a constructor that sets position to <code>beg</code>, and it calls <code>seekToSmallest()</code> to set <code>current</code> and <code>key_index</code> to the first key.  <code>end()</code> likewise calls
a constructor that sets position to <code>end</code>, and it calls <code>seekToLargest()</code> to set <code>current</code> and <code>key_index</code> to the last key.</p>

<p>If the <code>position</code> is 'beg', <code>decrement()</code> does a no-op, and none of the member varibles changes. If the <code>position</code> is 'end' and <code>increment()</code> is called, it, too,
does a no-op, and none of the member varibles changes. </p>

<h3>Red Black code</h3>

<p>This is the red black tree increment method fo stdlibc++ below that was used to guide the findLeafNodeSuccessor() code:</p>

<pre><code>// stdlibc++ source code for red black tree increment
static _Rb_tree_node_base*
  local_Rb_tree_increment(_Rb_tree_node_base* __x) throw ()
  {
    // If there is a right subtree, get its left most node.
    if (__x-&gt;_M_right != 0) 
      {
        __x = __x-&gt;_M_right;
        while (__x-&gt;_M_left != 0)
          __x = __x-&gt;_M_left;
      }
    else
      {
       // An illustration what the loop below is doing (in a balanced red black tree)
       // It ascend x's parent nodes as long as they are right children. It stops when the parent is not 
       /*
               57 
               / \
             55
               \
                40  
               /  \
             35   45
            / \   / \
           30 38 43  50 

          At this point we have a leaf node most likely. It could be a node that is a left child of its parent already, or it could be
          a right child, and its parent could likewise be a right child. In this case, we ascend until the node is no longer a right child.

        _Rb_tree_node_base* __y = __x-&gt;_M_parent; // else retrieve its parent 

        while (__x == __y-&gt;_M_right) // Ascend as long as the parent node is always a right child.
          {
            __x = __y;
            __y = __y-&gt;_M_parent;
          }
        if (__x-&gt;_M_right != __y) // I am not sure what this does?
            __x = __y;
      }
    return __x;
  }

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ()
  {
    return local_Rb_tree_increment(__x);
  }

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ()
  {
    return local_Rb_tree_increment(const_cast&lt;_Rb_tree_node_base*&gt;(__x));
  }
</code></pre>

<p>From http://www.sgi.com/tech/stl/stl_tree.h</p>

<pre><code>struct _Rb_tree_base_iterator
{
  typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
  typedef bidirectional_iterator_tag iterator_category;
  typedef ptrdiff_t difference_type;
  _Base_ptr _M_node;

  void _M_increment()
  {
    if (_M_node-&gt;_M_right != 0) {
      _M_node = _M_node-&gt;_M_right;
      while (_M_node-&gt;_M_left != 0)
        _M_node = _M_node-&gt;_M_left;
    }
    else {
      _Base_ptr __y = _M_node-&gt;_M_parent;
      while (_M_node == __y-&gt;_M_right) {
        _M_node = __y;
        __y = __y-&gt;_M_parent;
      }
      // Again, what is this for, comparing it to the illustration at
      // http://stackoverflow.com/questions/12684191/implementing-an-iterator-over-binary-or-arbitrary-tree-using-c-11 
      if (_M_node-&gt;_M_right != __y) 

        _M_node = __y;
    }
  }

  void _M_decrement()
  {
    if (_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp;
        _M_node-&gt;_M_parent-&gt;_M_parent == _M_node)
      _M_node = _M_node-&gt;_M_right;
    else if (_M_node-&gt;_M_left != 0) {
      _Base_ptr __y = _M_node-&gt;_M_left;
      while (__y-&gt;_M_right != 0)
        __y = __y-&gt;_M_right;
      _M_node = __y;
    }
    else {
      _Base_ptr __y = _M_node-&gt;_M_parent;
      while (_M_node == __y-&gt;_M_left) {
        _M_node = __y;
        __y = __y-&gt;_M_parent;
      }
      _M_node = __y;
    }
  }
};
</code></pre>

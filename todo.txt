Implement the code to clone the tree that the tree23 copy constructor and copy assignment operator both call. We will also need to implement a
DestroyTree method that will need to be first called to free the tree's nodes.

Can it the copying of each node be implemented as a functor that is passed to the pre-order traversal algorithm, something like this?

CloneFunctor {
   tree23<Key, Value>& tree;

   // Notes: references cannot be rebound, so we cannot use them.
   //--tree23<Key, Value>::Node23 *pnode_2clone; 

   std::unique_ptr<typename tree23<Key, Value>::Node23> node_2clone; 

   public:
        // Function call operator.  
        CloneFunctor(tree23<Key, Value>& lhs) : tree{lhs}, node_2clone{nullptr};
 
        void operator(const tree23<Key, Value>::Node23& node23);
};

// The code below isn't right. The logic is confused. How do we initially set and then later advance pnode_2clone?
void CloneFunctor<Key, Value>::operator(const tree23<Key, Value>::Node23& node23)
{
   tree23<Key, Value> Node23 tmp = std::make_unique<Node23>(node23); // This would require the copy ctor of node23 to be public       

   *pnode_2clone = std::move(node); // <-- This is confused logic

   // What should pnode_2clone be advanced to?

}

Using std::copy() would require external iterators, which the code does not
presently support.

As a last resort, the CloneTree() method in the tree234 code could be used.
